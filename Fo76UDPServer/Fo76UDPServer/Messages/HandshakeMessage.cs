using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Fo76UDPServer.Messages
{
    class HandshakeMessage
    {
        public bool IsValid;
        public HandshakeMessageType MessageType;
        public int DataLength1;
        public short Unk2;
        public int Unk3;
        public int DataLength2;
        public byte[] Data;

        public HandshakeMessage(byte[] data)
        {
            if (data.Length < 12)
            {
                IsValid = false;
                Console.WriteLine("Dropping packet " + Helpers.ByteArrayToString(data) + " Invalid length");
                return;
            }

            MemoryStream stream = new MemoryStream(data);
            this.MessageType = (HandshakeMessageType)stream.ReadByte();

            if (!Enum.IsDefined(typeof(HandshakeMessageType), this.MessageType))
            {
                IsValid = false;
                Console.WriteLine("Dropping packet " + Helpers.ByteArrayToString(data) + " Invalid Type");
                return;
            }

            this.DataLength1 = stream.ReadLittleEndian3Bytes();
            this.Unk2 = stream.ReadLittleEndianShort();
            this.Unk3 = stream.ReadLittleEndian3Bytes();
            this.DataLength2 = stream.ReadLittleEndian3Bytes();
            this.Data = new byte[data.Length - 12];
            Array.Copy(data, 12, this.Data, 0, this.Data.Length);
            stream.Close();
            IsValid = true;
        }

        public override string ToString()
        {
            if (!IsValid)
                return "Invalid packet";
            return MessageType.ToString();
        }

        public enum HandshakeMessageType : byte
        {
            //142B1A8F0
            HelloRequest = 0,
            ClientHello = 1,
            ServerHello = 2,
            HelloVerifyRequest = 3,
            Certificate = 0xB,
            ServerKeyExchange = 0xC,
            CertificateRequest = 0xD,
            ServerHelloDone = 0xE,
            CertificateVerify = 0xF,
            ClientKeyExchange = 0x10,
            Finished = 0x14,
            unknown = 0xFF
        }

        public static byte[] BuildHelloVerifyResponse(byte[] ServerRandom)
        {
            //TODO:reverse the other data in this request and build a better packet builder
            byte[] fillIn = { 0x16, 0xFE, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0xFE, 0xFF, 0x20, 0x5B, 0x7E, 0xE8, 0xA2, 0x44, 0x50, 0x31, 0xED, 0xD0, 0x51, 0xD1, 0x7C, 0xA7, 0x4B, 0xC6, 0x90, 0xFE, 0x46, 0xA2, 0x91, 0xC3, 0x83, 0x35, 0x4C, 0xBB, 0xF6, 0x62, 0x26, 0xF7, 0x19, 0xE6, 0xF0 };
            Array.Copy(ServerRandom, 0, fillIn, 0x1C, ServerRandom.Length);
            return fillIn;
        }

        public static byte[] BuildServerHelloResponse(byte[] ServerRandom)
        {
            byte[] fillIn = { 0x16, 0xFE, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x5D, 0x02, 0x00, 0x00, 0x2D, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2D, 0xFE, 0xFD, 0x6A, 0x46, 0x4E, 0xDF, 0xC8, 0xE0, 0x45, 0x96, 0x0C, 0x90, 0x1D, 0xC1, 0xF4, 0xC2, 0x90, 0x37, 0x87, 0xC8, 0x39, 0x95, 0x44, 0x7B, 0x2B, 0xE7, 0x87, 0x9D, 0xE4, 0xF7, 0x8E, 0x25, 0x91, 0xE1, 0x00, 0x00, 0xA8, 0x00, 0x00, 0x05, 0xFF, 0x01, 0x00, 0x01, 0x00, 0x0C, 0x00, 0x00, 0x0C, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x0A, 0x50, 0x52, 0x4F, 0x4A, 0x45, 0x43, 0x54, 0x5F, 0x37, 0x36, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
            Array.Copy(ServerRandom, 0, fillIn, 0x1B, ServerRandom.Length);
            return fillIn;
        }

        public static byte[] BuildHelloRequestResponse(Crypt cryptHandle,byte[] msgHash)
        {
            byte[] fillIn = { 0x16, 0xFE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFD, 0xA5, 0x3E, 0x38, 0x22, 0xCA, 0x35, 0x2D, 0x03, 0xEB, 0x8B, 0x73, 0x52, 0x2E, 0x3B, 0xBB, 0xFC, 0x81, 0x65, 0xED, 0x7E, 0xF6, 0xED, 0x95, 0xD6, 0xD7, 0x84, 0x25, 0x24, 0xB8, 0xE1, 0x08, 0x9B, 0x8D, 0xB0, 0x1C, 0xA9, 0x02, 0x3F, 0x24, 0x7F, 0x00, 0x00, 0xF0, 0xEF, 0x75, 0xDD, 0xF2, 0x00, 0x00, 0x00, 0x73, 0xF1, 0x71, 0xE3, 0xF7, 0x7F, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x0A, 0x50, 0x52, 0x4F, 0x4A, 0x45, 0x43, 0x54, 0x5F, 0x37, 0x36, 0x0E, 0x00, 0x01, 0x40, 0x1A, 0xC0 };
            byte[] fillInHashMsg = { 0x14, 0x00, 0x00, 0x0C, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0xC5, 0xF2, 0x8F, 0x41, 0xB8, 0x84, 0x8F, 0x96, 0xEA, 0x45, 0xDA, 0x65 };
            byte[] Tag;
            Array.Copy(msgHash, 0x0, fillInHashMsg, 0xC, msgHash.Length);
            var encryptedData = cryptHandle.Encrypt(fillInHashMsg, out Tag, new byte[] { 0x16, 0xFE, 0xFD }, 0);
            Array.Copy(encryptedData, 0, fillIn, 0x15, encryptedData.Length);
            Array.Copy(Tag, 0, fillIn, 0x2D, Tag.Length);
            Console.WriteLine("EncTag:" + Helpers.ByteArrayToString(Tag));
            Console.WriteLine("RESPONSE:" + Helpers.ByteArrayToString(fillIn));
            return fillIn;
        }
    }
}
